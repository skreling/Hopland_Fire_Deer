---
title: "Deer RSF Pre and Post Fire"
author: "Kaitlyn"
date: "5/28/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = F, warning = F, error = FALSE)
```

### Set up, import data

```{r}
library(lme4)
library(MuMIn)
library(caret)
library(ROCR)
library(tidyverse)
library(raster)
library(rgdal)
library(car)

`%notin%` <- Negate(`%in%`)
```


Read in dataframe and filter by time period.

This dataframe includes rows for used points and randomly-generated points, and associated values of landscape covariates as extracted from underlying raster layers.
```{r}
all_data <- read.csv("Publication_Data/Collars/RSF_input.csv") 

PreAll <- filter(all_data, Period == "Pre") 
PostAll <- filter(all_data, Period == "Post") 
```



### Model Selection

#### Narrowing in on covariates

Let's see what surviving vegetation layer is best.
survveg.1 is the rounding at 0.5
survveg.2 is the continuous
survveg.3 is the rounding > 0
```{r, eval = F}
# conservative binary factor
glmer(Case ~ survveg.1 + (1|AnimalID), family = "binomial", data = PostAll)      # 27371.31

# continuous
glmer(Case ~ survveg.2 + (1|AnimalID), family = "binomial", data = PostAll)      # 27246.44

# liberal binary factor - BEST ONE.
glmer(Case ~ survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)      # 27010.85 
```


#### Pre-Fire Models

Let's try backwards selection again.

```{r, eval = F}
(PreNull <- glmer(Case ~ (1|AnimalID), family = "binomial", data = PreAll))                                                                                     # 30303.20

(PreFull <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))    # 30107.17
  
# stepping backward from full model
(PreModel1.1 <- glmer(Case ~ elevation + slope + east + north + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))      #  30123.08
(PreModel1.2 <- glmer(Case ~ veg + slope + east + north + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))            # 30140.95
(PreModel1.3 <- glmer(Case ~ veg + elevation + east + north + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))        # 30166.65
(PreModel1.4 <- glmer(Case ~ veg + elevation + slope + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))                             # 30163.71
(PreModel1.5 <- glmer(Case ~ veg + elevation + slope + east + north + water + Sex + (1|AnimalID), family = "binomial", data = PreAll))           # 30110.71
(PreModel1.6 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + Sex + (1|AnimalID), family = "binomial", data = PreAll))         # 30118.21
(PreModel1.7 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PreAll))      # 30105.61 - best of this batch (no Sex)

# stepping backwards from PreModel1.7 - none improve on 1.7, still the best
(PreModel2.1 <- glmer(Case ~ elevation + slope + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PreAll)) # 30121.54 *
(PreModel2.2 <- glmer(Case ~ veg + slope + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PreAll)) # 30138.98 *
(PreModel2.3 <- glmer(Case ~ veg + elevation + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PreAll)) # 30165.17  *
(PreModel2.4 <- glmer(Case ~ veg + elevation + slope + rugged + water + (1|AnimalID), family = "binomial", data = PreAll)) # 30162.46 *
(PreModel2.5 <- glmer(Case ~ veg + elevation + slope + east + north + water + (1|AnimalID), family = "binomial", data = PreAll)) # 30109.23 *
(PreModel2.6 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + (1|AnimalID), family = "binomial", data = PreAll)) # 30116.76 *
```


#### Post-Fire Models


```{r, eval = F}
(PostNull <- glmer(Case ~ (1|AnimalID), family = "binomial", data = PostAll))                                                                            # 27762.54 *

(PostFull <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26152.42 *
vif(PostFull)

# stepping backward from full model
(PostModel1.1 <- glmer(Case ~ elevation + slope + east + north + rugged + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26761.53 *
(PostModel1.2 <- glmer(Case ~ veg + slope + east + north + rugged + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26191.72 *
(PostModel1.3 <- glmer(Case ~ veg + elevation + east + north + rugged + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26160.10 *
(PostModel1.4 <- glmer(Case ~ veg + elevation + slope + rugged + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26213.70 *
(PostModel1.5 <- glmer(Case ~ veg + elevation + slope + east + north + water + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26262.57 *
(PostModel1.6 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + survveg.3 + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26163.90 *
(PostModel1.7 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + Sex + (1|AnimalID), family = "binomial", data = PostAll)) # 26568.19 *
(PostModel1.8 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26150.56 # the best of the bunch

# stepping backwards from PostModel1.8 - none improve on 1.8, still the best
(PostFull2.1 <- glmer(Case ~ elevation + slope + east + north + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26759.72 *
(PostFull2.2 <- glmer(Case ~ veg + slope + east + north + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26189.99 *
(PostFull2.3 <- glmer(Case ~ veg + elevation + east + north + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26158.23 *
(PostFull2.4 <- glmer(Case ~ veg + elevation + slope + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26211.79 *
(PostFull2.5 <- glmer(Case ~ veg + elevation + slope + east + north + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26260.66 *
(PostFull2.6 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)) # 26162.02 *
(PostFull2.7 <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PostAll)) # 26566.35 *

```



### Interpretation of results

```{r}
best_model_pre <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + (1|AnimalID), family = "binomial", data = PreAll)

vif(best_model_pre) # check VIF
summary(best_model_pre)
```


The best pre-fire model includes the following covariates:

woodland = 1, chaparral = 2, grassland = 3

* vegetation/habitat: greatest selection for chaparral (2), then woodland (1), then grassland (3)
* elevation (+)
* slope (-)
* east (+)
* north (+)
* ruggedness (+)
* distance to streambed/water (+)


```{r}
best_model_post <- glmer(Case ~ veg + elevation + slope + east + north + rugged + water + survveg.3 + (1|AnimalID), family = "binomial", data = PostAll)

vif(best_model_post)
summary(best_model_post)
```


The best post-fire model includes the following covariates:

woodland = 1, chaparral = 2, grassland = 3

* vegetation/habitat: greatest selection for woodland (1), then grassland (3), then chaparral (2)
* elevation (+)
* slope (-)
* east (+)
* north (+)
* ruggedness (+)
* distance to streambed/water (+)
* surviving vegetation (+)


Both pre and post fire, deer showed similar patterns of selection for elevation, slope, aspect, ruggedness, and distance to streambed.

Notably, habitat selection patterns changed after the fire. The deer selected for woodland, then grassland, then chaparral. This makes sense, given that the woodland was the area with tree cover, and the other areas were burned to a crisp. Trees likely provided shade and shelter.

Surviving vegetation is the strongest predictor in the post-fire models. This, I think, is the main take-away.


### MODEL VALIDATION - individual level

Read in raster stacks, masked to study areas, for later validation.
```{r}
# bring in raw file for names (didn't export for some reason)
prestack_doe <- stack("data/RSF_NEW_12.2020/Area_Rasters/PreDoeStack2.grd")

# bring in the 13 individual stacks cropped to each deer's home range
individual_stacks <- list()
for (i in 1:13) {
  
  file_name <- paste("data/RSF_NEW_12.2020/Area_Rasters/individual_rasters/Stack_",
                     levels(all_data$AnimalID)[i], ".grd", sep = "")
  
  individual_stacks[[i]] <- stack(file_name)
  
  names(individual_stacks[[i]]) <- names(prestack_doe)
}

names(individual_stacks) <- levels(all_data$AnimalID)
```

Store factor levels in list (needed for predicting the model with the raster stack in validation and covariate plots)
```{r}
survveg.3.levels <- list(levels(all_data$survveg.3))
names(survveg.3.levels) <- "survveg.3"
```


#### Pre-Fire

```{r, echo = F}
set.seed(15)

simulations <- list()

nsim <- 100

for(j in 1:13) { # loop through the 13 individual deer

  for (i in 1:nsim){ # repeat for nsim iterations
    
    traintest <- PreAll %>%
      filter(AnimalID == names(individual_stacks[j])) %>% # filter for only that deer
      dplyr::mutate(n = row_number()) %>% #create row number if you dont have one
      dplyr::select(n, everything()) # put 'n' at the front of the dataset
  
    training <- traintest %>%
      group_by(Case) %>% # any number of variables you wish to partition by proportionally
      sample_frac(.8) # '.8' is the proportion of the original df you wish to sample
  
    testing <- anti_join(traintest, training) # creates test dataframe with those observations not in 'train.'
    
    test.model<- glm(Case ~ veg + elevation + slope + east + north + rugged + water, 
                       family="binomial",
                       data = training)
  
    testing$predict1 <- predict(test.model, testing, type="response")
    
    # needed to add line re.form = ~0 since there are no "random effects" when just predicting spatially
    rastpredict <- predict(individual_stacks[[j]], test.model, 
                           allow.new.levels=T, type="response", re.form=~0,
                           factors = veg.levels) 
    
    testingsub <- subset(testing,Case==1)
    
    quantpredict <- data.frame(quantile(testingsub$predict1,probs=c(seq(0,1,by=0.1))))
    
    binbreaks<-c(quantpredict[,1])
    binbreaks[1]<-0
    binbreaks[11]<-1
    
    reclass_df <- t(matrix(c(binbreaks[1:10],binbreaks[2:11],seq(1:10)),ncol=10,byrow=T))
    r1.class <- reclassify(rastpredict,reclass_df)
    r1.area<-data.frame(freq(r1.class))
    r1.area<-r1.area[-11,]
    r1.areas<-r1.area$count/sum(r1.area$count)
    
    testingsub$predictbins<-.bincode(testingsub$predict1,breaks=binbreaks)
    
    # to prevent error message in case of bin issue
    if(length((table(testingsub$predictbins)/sum(table(testingsub$predictbins)))) != length(r1.areas)) {
      
      simulations[[(nsim*(j-1) + i)]] <- NA
      
    } else {
          
        area.adjust<-data.frame(((table(testingsub$predictbins)/sum(table(testingsub$predictbins))))/r1.areas)
        
        area.adjust$AnimalID <- j
        
        simulations[[(nsim*(j-1) + i)]]<-area.adjust
    
    }

  }
}

simulations.all<-do.call(rbind, simulations)

simulations.all<-data.frame(simulations.all)

library(plyr)
kfold.ply<-ddply(simulations.all,.(Var1, AnimalID),summarize,mean=mean(Freq),sd=sd(Freq),count=length(Freq))

kfold.ply$se<-kfold.ply$sd/sqrt(kfold.ply$count)

kfold.ply$Var2<-as.numeric(kfold.ply$Var1)


# run correlation tests for each individual animal
cor.test.list <- list()
for(i in 1:13) {
  cor.test.list[[i]] <-
  cor.test(~mean+Var2,
         data = filter(kfold.ply, AnimalID == i),
         method = "spearman")
}

cor.test.list

#maxy<-max(kfold.ply$mean)+10*max(kfold.ply$se)

ggplot(kfold.ply, aes(x=Var1, y=mean,group=1)) + 
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) +
  theme_classic()+
  xlab("Binned RSF Score")+ylab("Area Adjusted Frequency")+
  ggtitle("Pre Fire") +
  geom_line() +  geom_point(size=2.5)+ 
 # ylim(0,maxy)+
  geom_hline(yintercept=1, linetype="dashed",size=1.5) +
  facet_wrap(~AnimalID, scales = "free")


## for all individuals combined

kfold.ply.all <- ddply(simulations.all,.(Var1),summarize,mean=mean(Freq),sd=sd(Freq),count=length(Freq))

kfold.ply.all$se<-kfold.ply.all$sd/sqrt(kfold.ply.all$count)

kfold.ply.all$Var2<-as.numeric(kfold.ply.all$Var1)

# run for all individuals combined
cor.test(~mean+Var2,
       data = kfold.ply.all,
       method = "spearman")

ggplot(kfold.ply.all, aes(x=Var1, y=mean,group=1)) + 
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) +
  theme_classic()+
  xlab("Binned RSF Score")+ylab("Area Adjusted Frequency")+
  ggtitle("Pre Fire") +
  geom_line() +  geom_point(size=2.5)+ 
 # ylim(0,maxy)+
  geom_hline(yintercept=1, linetype="dashed",size=1.5)
```

INDIVIDUAL DEER: 

[[1]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 80, p-value = 0.1328
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.5151515 


[[2]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 


[[3]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 14, p-value = 0.0004667
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9151515 


[[4]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 6, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9636364 


[[5]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 32, p-value = 0.008236
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.8060606 


[[6]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 48, p-value = 0.02751
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.7090909 


[[7]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 


[[8]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 6, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9636364 


[[9]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 6, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9636364 


[[10]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 16, p-value = 0.0008802
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9030303 


[[11]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 8, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9515152 


[[12]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 4, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9757576 


[[13]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 30, p-value = 0.006811
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.8181818 


ALL COMBINED:

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 

#### Post-Fire

```{r, echo = F}
set.seed(5)

simulations <- list()

nsim <- 100

for(j in 1:13) { # loop through the 13 individual deer

  for (i in 1:nsim){ # repeat for nsim iterations
    
    traintest <- PostAll %>%
      filter(AnimalID == names(individual_stacks[j])) %>% # filter for only that deer
      dplyr::mutate(n = row_number()) %>% #create row number if you dont have one
      dplyr::select(n, everything()) # put 'n' at the front of the dataset
  
    training <- traintest %>%
      group_by(Case) %>% # any number of variables you wish to partition by proportionally
      sample_frac(.8) # '.8' is the proportion of the original df you wish to sample
  
    testing <- anti_join(traintest, training) # creates test dataframe with those observations not in 'train.'
    
    test.model<- glm(Case ~ veg + elevation + slope + east + north + rugged + water + survveg.3, 
                     family="binomial",
                     data = training)
  
    testing$predict1 <- predict(test.model, testing, type="response")
    
    # needed to add line re.form = ~0 since there are no "random effects" when just predicting spatially
    rastpredict <- predict(individual_stacks[[j]], test.model, 
                           allow.new.levels=T, type="response", re.form=~0,
                           factors = c(veg.levels, survveg.3.levels)) 
    
    testingsub <- subset(testing,Case==1)
    
    quantpredict <- data.frame(quantile(testingsub$predict1,probs=c(seq(0,1,by=0.1))))
    
    binbreaks<-c(quantpredict[,1])
    binbreaks[1]<-0
    binbreaks[11]<-1
    
    reclass_df <- t(matrix(c(binbreaks[1:10],binbreaks[2:11],seq(1:10)),ncol=10,byrow=T))
    r1.class <- reclassify(rastpredict,reclass_df)
    r1.area<-data.frame(freq(r1.class))
    r1.area<-r1.area[-11,]
    r1.areas<-r1.area$count/sum(r1.area$count)
    
    testingsub$predictbins<-.bincode(testingsub$predict1,breaks=binbreaks)
    
    # to prevent error message in case of bin issue
    if(length((table(testingsub$predictbins)/sum(table(testingsub$predictbins)))) != length(r1.areas)) {
      
      simulations[[(nsim*(j-1) + i)]] <- NA
      
    } else {
          
        area.adjust<-data.frame(((table(testingsub$predictbins)/sum(table(testingsub$predictbins))))/r1.areas)
        
        area.adjust$AnimalID <- j
        
        simulations[[(nsim*(j-1) + i)]]<-area.adjust
    
    }
  }
}

simulations.all<-do.call(rbind, simulations)

simulations.all<-data.frame(simulations.all)

library(plyr)
kfold.ply<-ddply(simulations.all,.(Var1, AnimalID),summarize,mean=mean(Freq),sd=sd(Freq),count=length(Freq))

kfold.ply$se<-kfold.ply$sd/sqrt(kfold.ply$count)

kfold.ply$Var2<-as.numeric(kfold.ply$Var1)


# run correlation tests for each individual animal
cor.test.list <- list()
for(i in 1:13) {
  cor.test.list[[i]] <-
  cor.test(~mean+Var2,
         data = filter(kfold.ply, AnimalID == i),
         method = "spearman")
}

cor.test.list

#maxy<-max(kfold.ply$mean)+10*max(kfold.ply$se)

ggplot(kfold.ply, aes(x=Var1, y=mean,group=1)) + 
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) +
  theme_classic()+
  xlab("Binned RSF Score")+ylab("Area Adjusted Frequency")+
  ggtitle("Post Fire") +
  geom_line() +  geom_point(size=2.5)+ 
 # ylim(0,maxy)+
  geom_hline(yintercept=1, linetype="dashed",size=1.5) +
  facet_wrap(~AnimalID, scales = "free")


## for all individuals combined

kfold.ply.all <- ddply(simulations.all,.(Var1),summarize,mean=mean(Freq),sd=sd(Freq),count=length(Freq))

kfold.ply.all$se<-kfold.ply.all$sd/sqrt(kfold.ply.all$count)

kfold.ply.all$Var2<-as.numeric(kfold.ply.all$Var1)

# run for all individuals combined
cor.test(~mean+Var2,
       data = kfold.ply.all,
       method = "spearman")

ggplot(kfold.ply.all, aes(x=Var1, y=mean,group=1)) + 
  geom_errorbar(aes(ymin=mean-se, ymax=mean+se), width=.1) +
  theme_classic()+
  xlab("Binned RSF Score")+ylab("Area Adjusted Frequency")+
  ggtitle("Post Fire") +
  geom_line() +  geom_point(size=2.5)+ 
 # ylim(0,maxy)+
  geom_hline(yintercept=1, linetype="dashed",size=1.5)
```

[[1]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 32, p-value = 0.008236
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.8060606 


[[2]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 62, p-value = 0.06025
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.6242424 


[[3]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 10, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9393939 


[[4]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 


[[5]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 


[[6]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 4, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9757576 


[[7]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 18, p-value = 0.00138
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.8909091 


[[8]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 14, p-value = 0.0004667
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9151515 


[[9]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 8, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9515152 


[[10]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 24, p-value = 0.003505
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.8545455 


[[11]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 16, p-value = 0.0008802
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9030303 


[[12]]

	Spearman's rank correlation rho

data:  mean and Var2
S = 14, p-value = 0.0004667
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9151515 


DEER 13 - Q5 - did not converge, not sure why


ALL COMBINED:

	Spearman's rank correlation rho

data:  mean and Var2
S = 2, p-value < 2.2e-16
alternative hypothesis: true rho is not equal to 0
sample estimates:
      rho 
0.9878788 